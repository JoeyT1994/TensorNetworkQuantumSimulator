var documenterSearchIndex = {"docs":
[{"location":"#TensorNetworkQuantumSimulator","page":"Home","title":"TensorNetworkQuantumSimulator","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for TensorNetworkQuantumSimulator.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Base.truncate-Tuple{TensorNetworkState, Vararg{Any}}","page":"Home","title":"Base.truncate","text":"truncate(tns::TensorNetworkState; alg, args...; kwargs...)\nTruncate the bonds of a `TensorNetworkState` using the specified algorithm.\nThe supported algorithms are:\n- `\"bp\"`: Truncate using Belief Propagation.\n# Arguments\n- `tns::TensorNetworkState`: The tensor network state to be truncated.\n- `alg::String`: The truncation algorithm to use. Default is `nothing`, so it must be specified explicitly.\n- `args...`: Additional positional arguments specific to the chosen algorithm. These include cache update arguments in the form of a `NamedTuple` cache_update_kwargs.\n- `kwargs...`: Additional keyword arguments specific to the chosen algorithm. These include options like `maxdim` and `cutoff` for bond dimension truncation.\n# Returns\n- The truncated `tns::TensorNetworkState`.\n\n\n\n\n\n","category":"method"},{"location":"#ITensors.SiteTypes.op-Tuple{ITensors.SiteTypes.OpName{:Rxxyyzz}, ITensors.SiteTypes.SiteType{S=1/2}}","page":"Home","title":"ITensors.SiteTypes.op","text":"ITensors.op(::OpName\"Rxxyyzz\", ::SiteType\"S=1/2\"; θ::Number)\n\nGate for rotation by XXYYZZ at a given angle\n\n\n\n\n\n","category":"method"},{"location":"#ITensors.SiteTypes.op-Tuple{ITensors.SiteTypes.OpName{:Rxxyy}, ITensors.SiteTypes.SiteType{S=1/2}}","page":"Home","title":"ITensors.SiteTypes.op","text":"ITensors.op(::OpName\"Rxxyy\", ::SiteType\"S=1/2\"; θ::Number)\n\nGate for rotation by XXYY at a given angle\n\n\n\n\n\n","category":"method"},{"location":"#ITensors.SiteTypes.op-Tuple{ITensors.SiteTypes.OpName{:xx_plus_yy}, ITensors.SiteTypes.SiteType{S=1/2}}","page":"Home","title":"ITensors.SiteTypes.op","text":"ITensors.op(::OpName\"xx_plus_yy\", ::SiteType\"S=1/2\"; θ::Number, β::Number)\n\nGate for rotation by XX+YY at a given angle with Rz rotations either size. Consistent with qiskit.\n\n\n\n\n\n","category":"method"},{"location":"#ITensors.inner-Tuple{TensorNetworkState, TensorNetworkState}","page":"Home","title":"ITensors.inner","text":"inner(ψ::TensorNetworkState, ϕ::TensorNetworkState; alg, kwargs...)\n\nCompute the inner product between two TensorNetworkStates using the specified algorithm.\nThe two states should have the same graph structure and physical indices on each site.\n\n# Arguments\n- `ψ::TensorNetworkState`: The first tensor network state.\n- `ϕ::TensorNetworkState`: The second tensor network state.\n\n# Keyword Arguments\n- `alg`: The algorithm to use for the inner product calculation. Options include:\n    - `\"exact\"`: Exact contraction of the tensor network.\n    - `\"bp\"`: Belief propagation approximation.\n    - `\"boundarymps\"`: Boundary MPS approximation (requires `mps_bond_dimension`).\n    - `\"loopcorrections\"`: Loop corrections to belief propagation.\n- Extra kwargs for `alg = \"boundarymps\"`:\n    - `mps_bond_dimension::Integer`: The bond dimension for the boundary MPS approximation.\n    - `partition_by`: How to partition the graph for boundary MPS (default is `\"row\"`).\n    - `cache_update_kwargs`: Additional keyword arguments for updating the cache.\n- Extra kwargs for `alg = \"bp\"` or `\"loopcorrections\"`:\n    - `cache_update_kwargs`: Additional keyword arguments for updating the cache.\n    - `max_configuration_size`: Maximum configuration size for loop corrections (only for `\"loopcorrections\"`).\n\n# Returns\n- The computed inner product as a scalar value.\n\n# Example\n```julia\ns = siteinds(\"S=1/2\", g)\nψ = random_tensornetworkstate(ComplexF32, g, s; bond_dimension = 4)\nϕ = random_tensornetworkstate(ComplexF32, g, s; bond_dimension = 4)\n\n# Exact inner product\nip_exact = ITensors.inner(ψ, ϕ; alg = \"exact\")\n\n# Belief propagation inner product\nip_bp = ITensors.inner(ψ, ϕ; alg = \"bp\")\n\n# Boundary MPS inner product with bond dimension 10\nip_bmps = ITensors.inner(ψ, ϕ; alg = \"boundarymps\", mps_bond_dimension = 10)\n```\n\n\n\n\n\n","category":"method"},{"location":"#LinearAlgebra.normalize-Tuple{TensorNetworkState}","page":"Home","title":"LinearAlgebra.normalize","text":"normalize(tns::TensorNetworkState; alg, kwargs...)\nNormalize a `TensorNetworkState` using the specified algorithm.\n\n# Arguments\n- `tns::TensorNetworkState`: The tensor network state to be normalized.\n\n# Keyword Arguments\n- `alg`: The algorithm to use for normalization. Currently, only `\"bp\"` is supported.\n\n# Returns\n- The normalized `tns::TensorNetworkState` such that `norm_sqr(tns; alg) = 1`.\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.apply_gates-Tuple{Vector, TensorNetworkState}","page":"Home","title":"TensorNetworkQuantumSimulator.apply_gates","text":"apply_gates(circuit::Vector, ψ::Union{TensorNetworkState, BeliefPropagationCache}; bp_update_kwargs = default_bp_update_kwargs(ψ), kwargs...)\nApply a sequence of gates to a `TensorNetworkState` or a `BeliefPropagationCache`` wrapping a `TensorNetworkState`` using Belief Propagation to update the environment.\n# Arguments\n- `circuit::Vector`: A vector of tuples where each tuple contains a gate (as an `ITensor`) and the vertices it acts on.\n- `ψ::TensorNetworkState`: The tensor network state to which the gates will be applied.\n- `bp_update_kwargs`: Keyword arguments for updating the Belief Propagation cache between gates (reasonable defaults are set).\n- `apply_kwargs`: Keyword arguments for the gate application. These include options like `maxdim` and `cutoff` for bond dimension truncation during gate application.\n# Returns\n- A tuple containing the updated `TensorNetworkState` or `BeliefPropagationCache` and a vector of truncation errors for each gate application.\n\nend\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.expect-Tuple{Union{BeliefPropagationCache, TensorNetworkQuantumSimulator.BoundaryMPSCache, TensorNetworkState}, Any}","page":"Home","title":"TensorNetworkQuantumSimulator.expect","text":"expect(ψ, observable; alg=\"exact\", kwargs...) -> Number or Vector{Number}\n\nArguments:\n\nψ::Union{TensorNetworkState, BeliefPropagationCache, BoundaryMPSCache}: The TensorNetworkState (TNS) or cache wrapping the TNS to measure the observable(s) on.\nobservable::Union{Tuple, Vector{<:Tuple}}: The observable(s) to measure. Should be a tuple or vector of tuples of the form (ops, vertices, coeff=1).\nalg::Union{String, Nothing}: The algorithm to use for the measurement. \n\nKeyword Arguments:\n\ncache_update_kwargs...: Keyword arguments passed to the update function when using bp or boundarymps algorithms.\n\nReturns:\n\nA single number if measuring one observable, or a vector of numbers if measuring multiple observables.\n\nSupported algorithms:\n\n\"exact\": Exact contraction of the tensor network.\n\"bp\": Belief propagation approximation.\n\"boundarymps\": Boundary MPS approximation (requires mps_bond_dimension kwarg).\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.heavy_hexagonal_lattice-Tuple{Int64, Int64}","page":"Home","title":"TensorNetworkQuantumSimulator.heavy_hexagonal_lattice","text":"heavy_hexagonal_lattice(nx::Int64, ny::Int64)\n\nCreate heavy-hexagonal lattice geometry with nx columns of heavy-hexes and ny rows\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.identitytensornetworkstate","page":"Home","title":"TensorNetworkQuantumSimulator.identitytensornetworkstate","text":"identitytensornetwork(tninds::IndsNetwork)\n\nTensor network (in Heisenberg picture) for identity matrix on given IndsNetwork\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkQuantumSimulator.lieb_lattice-Tuple{Int64, Int64}","page":"Home","title":"TensorNetworkQuantumSimulator.lieb_lattice","text":"lieb_lattice(nx::Int64, ny::Int64; periodic = false)\n\nCreate Lieb lattice geometry with nx columns of decorated squared and ny rows\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.paulirotationmatrix-Tuple{Any, Any}","page":"Home","title":"TensorNetworkQuantumSimulator.paulirotationmatrix","text":"paulirotationmatrix(generator, θ)\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.paulitensornetworkstate","page":"Home","title":"TensorNetworkQuantumSimulator.paulitensornetworkstate","text":"topaulitensornetwork(op, g::NamedGraph)\n\nTensor network (in Heisenberg picture). Function should map vertices of the graph to pauli strings.\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkQuantumSimulator.random_tensornetworkstate","page":"Home","title":"TensorNetworkQuantumSimulator.random_tensornetworkstate","text":"random_tensornetworkstate(eltype, g::AbstractGraph, sitetype::String, d::Integer = site_dimension(sitetype); bond_dimension::Integer = 1)\nGenerate a random TensorNetworkState on graph `g` with local state indices generated from the `sitetype` string (e.g. \"S=1/2\", \"Pauli\") and the local dimension `d` (default is 2 for \"S=1/2\", 4 for Pauli etc).\n\nArguments:\n- `eltype`: (Optional) The number type of the tensor elements (e.g. Float64, ComplexF32). Default is Float64.\n- `g::AbstractGraph`: The underlying graph of the tensor network.\n- `sitetype::String`: A string representing the type of local site (e.g. \"S=1/2\", \"Pauli\").\n- `d::Integer`: The local dimension of the site (default is determined by `sitetype`).\n- `bond_dimension::Integer`: The bond dimension of the virtual indices connecting neighboring tensors (default is 1).\nReturns:\n- A `TensorNetworkState` object representing the random tensor network state.\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkQuantumSimulator.random_tensornetworkstate-2","page":"Home","title":"TensorNetworkQuantumSimulator.random_tensornetworkstate","text":"random_tensornetworkstate(eltype, g::AbstractGraph, siteinds::Dictionary; bond_dimension::Integer = 1)\nGenerate a random TensorNetworkState on graph `g` with local state indices given by the dictionary `siteinds`.\n\nArguments:\n- `eltype`: (Optional) The number type of the tensor elements (e.g. Float64, ComplexF32). Default is Float64.\n- `g::AbstractGraph`: The underlying graph of the tensor network.\n- `siteinds::Dictionary`: A dictionary mapping vertices to ITensor indices representing the local states. Defaults to spin 1/2.\n- `bond_dimension::Integer`: The bond dimension of the virtual indices connecting neighboring tensors (default is 1).\n\nReturns:\n- A `TensorNetworkState` object representing the random tensor network state.\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkQuantumSimulator.sample-Tuple{TensorNetworkState, Integer}","page":"Home","title":"TensorNetworkQuantumSimulator.sample","text":"sample(\n    ψ::ITensorNetwork,\n    nsamples::Integer;\n    projected_message_rank::Integer,\n    norm_message_rank::Integer,\n    norm_message_update_kwargs=(; niters = _default_boundarymps_update_niters, tolerance = _default_boundarymps_update_tolerance),\n    projected_message_update_kwargs = (;cutoff = _default_boundarymps_update_cutoff, maxdim = projected_message_rank),\n    partition_by = \"Row\",\n    kwargs...,\n)\n\nTake nsamples bitstrings, based on the square of the coefficients of the vector defined by a 2D open boundary tensornetwork.\n\nArguments\n\nψ::ITensorNetwork: The tensornetwork state to sample from.\nnsamples::Integer: Number of samples to draw.\n\nKeyword Arguments\n\nalg ::String: The algorithm to use for sampling (default is \"boundarymps\", which is the only option currently supported).\n\nSupported kwargs for alg = \"boundarymps\":     - projected_mps_bond_dimension::Int: Bond dimension of the projected boundary MPS messages used during contraction of the projected state <x|ψ>.     - norm_mps_bond_dimension::Int: Bond dimension of the boundary MPS messages used to contract <ψ|ψ>.     - norm_message_update_kwargs: Keyword arguments for updating the norm boundary MPS messages.     - projected_message_update_kwargs: Keyword arguments for updating the projected boundary MPS messages.     - partition_by: How to partition the graph for boundary MPS (default is \"Row\").\n\nReturns\n\nA vector of bitstrings sampled from the probability distribution defined by as a dictionary mapping each vertex to a configuration (0...d).\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.sample_certified-Tuple{TensorNetworkState, Int64}","page":"Home","title":"TensorNetworkQuantumSimulator.sample_certified","text":"sample_certified(\n    ψ::ITensorNetwork,\n    nsamples::Integer;\n    projected_message_rank::Integer,\n    norm_message_rank::Integer,\n    norm_message_update_kwargs=(; niters = _default_boundarymps_update_niters, tolerance = _default_boundarymps_update_tolerance),\n    projected_message_update_kwargs = (;cutoff = _default_boundarymps_update_cutoff, maxdim = projected_message_rank),\n    partition_by = \"Row\",\n    kwargs...,\n)\n\nTake nsamples bitstrings from a 2D open boundary tensornetwork. The samples are drawn from x~q(x) and for each sample an independent contraction of <x|ψ> is performed to get a measure of p(x)/q(x).\n\nArguments\n\nψ::ITensorNetwork: The tensornetwork state to sample from.\nnsamples::Integer: Number of samples to draw.\n\nKeyword Arguments\n\nalg ::String: The algorithm to use for sampling (default is \"boundarymps\", which is the only option currently supported).\n\nSupported kwargs for alg = \"boundarymps\":     - projected_mps_bond_dimension::Int: Bond dimension of the projected boundary MPS messages used during contraction of the projected state <x|ψ>.     - norm_mps_bond_dimension::Int: Bond dimension of the boundary MPS messages used to contract <ψ|ψ>.     - certification_mps_bond_dimension::Int: Bond dimension of the boundary MPS messages used to contract <x|ψ> for certification.     - norm_message_update_kwargs: Keyword arguments for updating the norm boundary MPS messages.     - projected_message_update_kwargs: Keyword arguments for updating the projected boundary MPS messages.     - partition_by: How to partition the graph for boundary MPS (default is \"Row\").\n\nReturns\n\nVector of NamedTuples. Each NamedTuple contains:\n\npoverq: Approximate value of p(x)/q(x) for the sampled bitstring x.\nbitstring: The sampled bitstring as a dictionary mapping each vertex to a configuration (0...d).\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.sample_directly_certified-Tuple{TensorNetworkState, Integer}","page":"Home","title":"TensorNetworkQuantumSimulator.sample_directly_certified","text":"sample_directly_certified(\n    ψ::ITensorNetwork,\n    nsamples::Integer;\n    projected_message_rank::Integer,\n    norm_message_rank::Integer,\n    norm_message_update_kwargs=(; niters = _default_boundarymps_update_niters, tolerance = _default_boundarymps_update_tolerance),\n    projected_message_update_kwargs = (;cutoff = _default_boundarymps_update_cutoff, maxdim = projected_message_rank),\n    partition_by = \"Row\",\n    kwargs...,\n)\n\nTake nsamples bitstrings from a 2D open boundary tensornetwork. The samples are drawn from x~q(x) and for each sample <x|ψ> is calculated \"on-the-fly\" to get a measure of p(x)/q(x).\n\nArguments\n\nψ::ITensorNetwork: The tensornetwork state to sample from.\nnsamples::Integer: Number of samples to draw.\n\nKeyword Arguments\n\nalg ::String: The algorithm to use for sampling (default is \"boundarymps\", which is the only option currently supported).\n\nSupported kwargs for alg = \"boundarymps\":     - projected_mps_bond_dimension::Int: Bond dimension of the projected boundary MPS messages used during contraction of the projected state <x|ψ>.     - norm_mps_bond_dimension::Int: Bond dimension of the boundary MPS messages used to contract <ψ|ψ>.     - norm_message_update_kwargs: Keyword arguments for updating the norm boundary MPS messages.     - projected_message_update_kwargs: Keyword arguments for updating the projected boundary MPS messages.     - partition_by: How to partition the graph for boundary MPS (default is \"Row\").\n\nReturns\n\nVector of NamedTuples. Each NamedTuple contains:\n\npoverq: Approximate value of p(x)/q(x) for the sampled bitstring x.\nlogq: Log probability of drawing the bitstring.\nbitstring: The sampled bitstring as a dictionary mapping each vertex to a configuration (0...d).\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.tensornetworkstate","page":"Home","title":"TensorNetworkQuantumSimulator.tensornetworkstate","text":"tensornetworkstate(eltype, f::Function, g::AbstractGraph, siteinds::Dictionary)\nConstruct a TensorNetworkState on graph `g` where the function `f` maps vertices to local states.\nThe local states can be given as strings (e.g. \"↑\", \"↓\", \"0\", \"1\", \"I\", \"X\", \"Y\", \"Z\") or as vectors of numbers (e.g. [1,0], [0,1], [1/sqrt(2), 1/sqrt(2)]).\n\nArguments:\n- `eltype`: (Optional) The number type of the tensor elements (e.g. Float64, ComplexF32). Default is Float64.\n- `f::Function`: A function mapping vertices of the graph to local states.\n- `g::AbstractGraph`: The underlying graph of the tensor network.\n- `siteinds::Dictionary`: A dictionary mapping vertices to ITensor indices representing the local states. Defaults to spin 1/2.\nReturns:    \n- A `TensorNetworkState` object representing the constructed tensor network state.\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkQuantumSimulator.tensornetworkstate-2","page":"Home","title":"TensorNetworkQuantumSimulator.tensornetworkstate","text":"tensornetworkstate(eltype, f::Function, g::AbstractGraph, sitetype::String, d::Integer = site_dimension(sitetype))\nConstruct a TensorNetworkState on graph `g` where the function `f` maps vertices to local states.\nThe local states can be given as strings (e.g. \"↑\", \"↓\", \"0\", \"1\", \"I\", \"X\", \"Y\", \"Z\") or as vectors of numbers (e.g. [1,0], [0,1], [1/sqrt(2), 1/sqrt(2)]).\n\nArguments:\n- `eltype`: (Optional) The number type of the tensor elements (e.g. Float64, ComplexF32). Default is Float64.\n- `f::Function`: A function mapping vertices of the graph to local states.\n- `g::AbstractGraph`: The underlying graph of the tensor network.\n- `sitetype::String`: A string representing the type of local site (e.g. \"S=1/2\", \"Pauli\").\n- `d::Integer`: The local dimension of the site (default is determined by `sitetype`).\n\nReturns:\n- A `TensorNetworkState` object representing the constructed tensor network state.\n\n\n\n\n\n","category":"function"},{"location":"#TensorNetworkQuantumSimulator.update-Tuple{NDTensors.BackendSelection.Algorithm{:bp}, TensorNetworkQuantumSimulator.AbstractBeliefPropagationCache}","page":"Home","title":"TensorNetworkQuantumSimulator.update","text":"More generic interface for update, with default params\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.update_iteration-Tuple{NDTensors.BackendSelection.Algorithm{:bp}, TensorNetworkQuantumSimulator.AbstractBeliefPropagationCache, Vector}","page":"Home","title":"TensorNetworkQuantumSimulator.update_iteration","text":"Do a sequential update of the message tensors on edges\n\n\n\n\n\n","category":"method"},{"location":"#TensorNetworkQuantumSimulator.zerostate","page":"Home","title":"TensorNetworkQuantumSimulator.zerostate","text":"zerostate(g::NamedGraph)\n\nTensor network for vacuum state on given graph, i.e all spins up\n\n\n\n\n\n","category":"function"}]
}
